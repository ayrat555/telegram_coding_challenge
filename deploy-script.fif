#!/usr/bin/env fift -s
"TonUtil.fif" include
"Asm.fif" include

{ ."usage: " @' $0 type ." <workchain-id> <required_keys_number> <keys_number> <public_key1> .. <public_key_keys_number>" cr
  ."Creates a new multisig contract in specified workchain that requires <required_keys_number> of <keys_numbers> to make a transfer" cr
  1 halt
} : usage

$# 4 < { usage } if

$1 parse-workchain-id =: workchain_id
$2 parse-int =: required_keys
$3 parse-int =: keys_number

"multisig_wallet5" =: multisig_wallet_file

."workchain_id = " workchain_id . cr
."required_keys = " required_keys . cr
."keys_number = " keys_number . cr

$# 3 - =: actual_public_keys

keys_number actual_public_keys > { ."Passed public keys number is too small" cr 1 halt } if

dictnew 0 2constant public_keys_dict
{ @' public_keys_dict } : public_keys_dict@
{ public_keys_dict@ nip } : public_key#

{ <b swap $, b> <s  public_keys_dict@ swap 16  udict!+  drop public_key# 1+  2 'nop does : public_keys_dict } : add_public_key


// fetching public keys to list
null 3 {  1 + dup  $# - } { dup $() rot cons swap  } while
$() swap cons
=: public_keys_list

public_keys_list { dup car add_public_key cdr } keys_number times

drop

PROGRAM{
  // automatically generated from `./multisig/multisig.fc`
  68762 DECLMETHOD required_number
  DECLPROC recv_internal
  DECLPROC recv_external
  required_number PROC:<{
    c4 PUSH
    CTOS
    32 LDI
    DROP
  }>
  recv_internal PROC:<{
    DROP
  }>
  recv_external PROC:<{
    9 PUSHPOW2
    LDSLICEX
    DUP
    32 LDU
    c4 PUSH
    CTOS
    32 LDU
    256 LDU
    32 LDU
    32 LDU
    LDREF
    ENDS
    s6 s4 XCPU
    EQUAL
    33 THROWIFNOT
    s0 s6 XCHG
    HASHSU
    s0 s7 s2 XC2PU
    CHKSIGNU
    34 THROWIFNOT
    ACCEPT
    s2 s0 XCPU
    SREFS
    IF:<{
      8 LDU
      LDREF
      s0 s2 XCHG
      SENDRAWMSG
    }>
    ENDS
    INC
    NEWC
    32 STU
    256 STU
    s1 s3 XCHG
    32 STU
    32 STU
    STREF
    ENDC
    c4 POP
  }>
}END>c
// code
<b 0 32 u,
   multisig_wallet_file +".pk" load-generate-keypair constant wallet_pk .s B, ."genere" .s
   required_keys 32 u,
   keys_number 32 u,
   public_keys_dict@ drop .s ref, .s
   b> // data
null // no libraries
<b b{0011} s, 3 roll ref, rot ref, swap dict, b>  // create StateInit
.s
dup ."StateInit: " <s csr. cr
dup hash workchain_id swap 2dup 2constant wallet_addr
."new wallet address = " 2dup .addr cr
2dup multisig_wallet_file +".addr" save-address-verbose
."Non-bounceable address (for init): " 2dup 7 .Addr cr
."Bounceable address (for later access): " 6 .Addr cr
cr
."hererererer" cr
.s

<b 0 32 u,
   b>
dup ."signing message: "  <s csr. cr

dup  hash wallet_pk ed25519_sign_uint .s cr cr rot

<b b{1000100} s, wallet_addr addr, b{000010} s, .s cr swap <s s, b{0} s, swap B, swap <s s, b>

dup ."External message for initialization is " <s csr. cr
2 boc+>B dup Bx. cr
multisig_wallet_file +"-query.boc" tuck B>file
."(Saved wallet creating query to file " type .")" cr

."last"
.s